#!/usr/bin/env python
#Required imports
#Module for testing detecting rectangles using rectangle dection in OpenCV
from __future__ import division
import cv2
import numpy as np
import rospy
import sys
# Required imports
from sensor_msgs.msg import Image
from std_msgs.msg import Bool, Int32MultiArray
from cv_bridge import CvBridge, CvBridgeError
from actionlib_msgs.msg import *

class rec_Detection():
    def __init__(self):
    # Initialise a publisher to publish messages to the robot base
        # Initialise bridge to CV bridge
        self.bridge = CvBridge()
        # Initialise required publishers to publish messages
        self.sub = rospy.Subscriber('topic1', Image, self.imageCallback)
        # Publisher for rectangle topic 2
        self.publisher_rect_detect = rospy.Publisher('topic2', Bool, queue_size=10)
        # Publisher for rectangle topic 3
        self.publisher_rect = rospy.Publisher('topic3', Bool, queue_size=10)
        # Publisher for identify four corners of rectangles
        self.publisher_rect_integer = rospy.Publisher('topic4_integer', Int32MultiArray, queue_size=10)

        # Initialise the value you wish to use for sensitivity in the colour detection (10 should be enough)
        # Initialise hue value
        self.sensitivity_hue_value = 30 #20
        # Initialise saturation value
        self.sensitivity_saturation_value = 10 #10
        # Initialise sensitivity value
        self.sensitivity_value = 10 #10
        # Initialise the value you wish to use for sensitivity of the colour of Cluedo border

        # Initialise hue upper and lower bounds
        self.upper_bound_hue = 180.0
        self.lower_bound_hue = 110.0
        # Initialise saturation upper and lower bounds
        self.saturation_upper = 15.0 / 100 * 255
        self.saturation_lower = 0.0 / 100 * 255
        self.upper_bound_value = 10.0 / 100 * 255
        self.lower_bound_value = 0.0 / 100 * 255
        # Initialise x1 ad y1
        self.x1 = 0
        self.y1 = 0

    # ROS calls the imageCallback function when a new image arrives on the topic
    def imageCallback(self, data):
        # Convert the received image into a opencv image
        # But remember that you should always wrap a call to this conversion method in an exception handler
        try:
            cv_image = self.bridge.imgmsg_to_cv2(data)
        except CvBridgeError as e:
            print(e)

        self.x1 = cv_image.shape[1]
        self.y1 = cv_image.shape[0]
        # Set the upper and lower bounds for the two colours you wish to identify
        # hue value = 0, 60 or 120 (red, green, or blue)
        # white = RGB(255,255.255)
        # black = RGB(0,0.0)
        lower_bound_black_border = np.array([self.lower_bound_hue - self.sensitivity_hue_value, self.saturation_lower - self.sensitivity_saturation_value, self.lower_bound_value - self.sensitivity_value])
        upper_bound_black_border = np.array([self.upper_bound_hue + self.sensitivity_hue_value, self.saturation_upper + self.sensitivity_saturation_value, self.upper_bound_value + self.sensitivity_value])

        # Convert the rgb image into a hsv image
        HSV_image_conversion = cv2.cvtColor(cv_image, cv2.COLOR_BGR2HSV)
        # Filter out everything but particular colours using the cv2.inRange() method
        # Skip combining masks as only one mask created
        mask1 = cv2.inRange(HSV_image_conversion, lower_bound_black_border, upper_bound_black_border)
        # Apply the mask to the original image using the cv2.bitwise_and() method
        # As mentioned on the worksheet the best way to do this is to bitwise and an image with itself and pass the mask to the mask parameter
        # As opposed to performing a bitwise_and on the mask and the image.
        mask_applied = cv2.bitwise_and(cv_image, cv_image, mask=mask1)
        self.detectRectangle(self, mask_applied)

    def detectRectangle(self, rect_detect_variable, cv_image):
        isRectangle = cv_image.copy()
        # Filter black colour for brder
        colour_black = np.where(
            (cv_image[:, :, 0] == 0) & #CV Image 0 0
            (cv_image[:, :, 1] == 0) & #CV Image 1 0
            (cv_image[:, :, 2] == 0)   #CV Image 2 0
        )
        # Black border output as white
        # RGB decimal for colour white
        # Change image black to white
        cv_image[colour_black] = [255, 255, 255]
        # Contour values for image not black
        contour_not_black = np.where(
            (cv_image[:, :, 0] != 255) & # 0 255 Does not equal white
            (cv_image[:, :, 1] != 255) & # 1 255
            (cv_image[:, :, 2] != 255)   # 2 255
        )

        # cx, cy = int(M['m10']/M['m00']), int(M['m01']/M['m00'])

        # Set flags to False if rectangle not detected
        flag_rectangle = False
        flag_rect_in_bounds = False
        # initialise check to 0
        c_x_m = 0
        c_y_m = 0
        c_x_n = 0
        c_y_n = 0

        # Find the contours that appear within the certain colour mask using the cv2.findContours() method
        if len(contour_not_black[0]) >= 70:
            flag_rectangle = True
            # Obtain boundaries of white and black on border
            c_x_m = min(contour_not_black[0])
            c_y_m = min(contour_not_black[1])
            c_x_n = max(contour_not_black[0])
            c_y_n = max(contour_not_black[1])
            # To detemine flag whether rectangle is in bounds
            # Values for determining in bound required to be cxm > 50 AND cym > 20
            if c_x_m > 70 and c_x_n < self.x1 - 70 and c_y_m > 30 and c_x_n < self.y1 - 30: # 50, 20
                flag_rect_in_bounds = True
            # draw a rectangle on the contour you're identifying
            # RGB 255 for white
            cv2.rectangle(isRectangle, (c_y_m, c_x_m), (c_y_n, c_x_n), (255, 255, 255), 3)

        # Publishing required data
        self.publisher_rect_detect.publish(flag_rectangle)
        if flag_rectangle:
            self.publisher_rect_integer.publish(data=[c_x_m, c_y_m, c_x_n, c_y_n])
        cv2.imshow("isRectangle", np.hstack([cv_image, isRectangle]))
        cv2.waitKey(5)

# Create a node of your class in the main and ensure it stays up and running
# handling exceptions and such
def main(args):
    # Instantiate your class
    # And rospy.init the entire node
	#rospy.init_node('rectangle_identification', anonymous=True)
    rospy.init_node('rectangle_identification', anonymous=True)
    rect_detect_variable = rec_Detection()
    print("Program Running")
    # Ensure that the node continues running with rospy.spin()
    # You may need to wrap it in an exception handler in case of KeyboardInterrupts
    try:
        rospy.spin()
    except rospy.ROSInterruptException:
        pass

# Check if the node is executing in the main path
if __name__ == '__main__':
    main(sys.argv)
